# <center>基础安装</center>

目标: Windows + Arch Linux, 双系统

示例机器情况:

1. 联想笔记本(CPU: AMD; 显卡: 核显; 硬盘: 一个 1T; 内存: 16G)
2. 硬盘分区: EFI 分区(600M), C 盘(256G), D 盘(144G), E 盘(296G), 末尾未分配(256G)
3. 镜像版本: `archlinux-2025.11.01-x86_64.iso`

可参考文档:

1. [ArchLinuxGuide](https://github.com/SHORiN-KiWATA/ShorinArchExperience-ArchlinuxGuide)
2. [arch-guide](https://github.com/nakanomikuorg/arch-guide)
3. [ArchLinuxTutorial](https://archlinuxstudio.github.io/ArchLinuxTutorial/#/)
4. [Arch Wiki](https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)
5. [arch-install-guide](https://github.com/gnuunixchad/arch-install-guide)

# 前期准备

> 快速启动功能很可能导致双系统之间写 NTFS 分区的时候丢数据

控制面板 -> 硬件和声音 -> 电源选项 -> 系统设置 : 取消勾选 "启用快速启动", 保存修改

或者彻底一点, 管理员权限执行: `powercfg /H off`, 关闭快速启动和休眠

---

参考: [系统时间](https://wiki.archlinuxcn.org/wiki/系统时间)

同步双系统硬件时间时区计算方式(硬件时间为UTC, 根据系统时区再加减), PowerShell 管理员执行命令:

```
Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1
```

---

磁盘分区处理(Windows):

1. 打开 `磁盘管理`, 设置一块未分配的分区用于安装 Linux
2. 若硬盘用了 Bitlocker 加密, 记得提前获取解密密钥, 后面要用
3. 下载 `Ventoy` , 制作启动盘, 下载 Linux ISO 放进 U 盘内
4. 进 BIOS, 关闭安全启动(security boot), 设置 U 盘为优先启动项, 确认启动模式是 UEFI
5. 重启, 进入启动盘, 选 ISO, `Boot in normal mode`, `Arch Linux install medium(x86_64, UEFI)`

# 手动安装

安装流程

```bash
# 查看网络连接状态, 获取网卡名称(一般是wlan0, 少数是wlp2s0之类)
ip a
ip link
lspci -k | grep Network # 可查看无线网卡驱动情况

# 连接Wi-Fi
iwctl
device list # 列出设备
station wlan0 scan # 扫描网络
station wlan0 get-networks # 列出Wi-Fi
station wlan0 connect "wifi名称" # 按提示输入密码
station wlan0 show # 查看连接状态
# station wlan0 disconnect # 断开连接
exit

# 测试网络
ping -w 3 baidu.com

# 更新系统时钟
timedatectl set-ntp true # 开启自动同步网络时间
timedatectl status # 检查时间

# 配置镜像源
reflector -a 24 -c cn -f 10 --sort score --save /etc/pacman.d/mirrorlist --v # 自动更新源
# 参数: 最近24小时更新过的;中国镜像;速度最快10个;下载质量评分排序;保存地址;过程可视化
# vim /etc/pacman.d/mirrorlist # 或者不用reflector, 自己选一些源放前面

# 更新软件仓库数据并下载keyring(一组官方的GPG密钥包, 用公钥验证安装包是否可信)
pacman -Sy archlinux-keyring

# 分区
lsblk -f # 查看硬盘, 记住硬盘名(示例为/dev/nvme0n1)
parted /dev/nvme0n1 print free # 可查看硬盘分区情况(包含未分配), 也可以fdisk -l /dev/xxx
cfdisk /dev/nvme0n1 # 硬盘分区, TUI界面操作
# 1) 选中要安装的空间, 未分配的"Free space" → New → 输入 200M → Enter
# 注: EFI分区只分配200M是在ESP挂载点为/efi且grub装进ESP的情况下, 其他方案用1G保险一点
# 2) 修改 Type 选 “EFI System”
# 3) 选中剩下的 Free space → New → 直接 Enter 用完剩余空间
# 4) Type 选 “Linux filesystem”
# 5) 选择 Write → yes → Quit
# 注: 创建单独的Linux EFI分区, 不和Win混用, 可防止Win更新破坏

# 格式化
# 示例为分区 nvme0n1p6(EFI) 和 nvme0n1p7
mkfs.fat -F 32 /dev/nvme0n1p6 # Linux 的新 EFI 分区(FAT32)
mkfs.btrfs /dev/nvme0n1p7 # 根分区(btrfs), 可用-f参数强制格式化

# 临时挂载, 创建 btrfs 子卷
mount -t btrfs /dev/nvme0n1p7 /mnt # 挂载磁盘分区
# /mnt目录常用于临时挂载外部设备
# 此处将磁盘挂载在U盘系统(live环境)的/mnt目录, 准备安装系统进磁盘
# 此时安装进去的/mnt, 就是后面系统的根分区(/)
btrfs subvolume create /mnt/@ # root子卷(存系统文件)
btrfs subvolume create /mnt/@home # home子卷(存用户文件)
btrfs subvolume create /mnt/@swap # swap子卷(内存够且不需要休眠功能可考虑不用)
btrfs subvolume list -p /mnt # 查看创建的子卷
umount /mnt # 取消挂载

# 正式挂载
# -o 指定额外的挂载参数
# compress=zstd 指用zstd压缩算法做透明压缩(可改参数如zstd:3调压缩等级, 最高15)
# 透明压缩: btrfs特性, 写入磁盘前先压缩数据, CPU占用小可忽略
mount -t btrfs -o subvol=/@,compress=zstd /dev/nvme0n1p7 /mnt # root子卷
mount --mkdir -t btrfs -o subvol=/@home,compress=zstd /dev/nvme0n1p7 /mnt/home # home子卷
mount --mkdir -t btrfs -o subvol=/@swap,compress=zstd /dev/nvme0n1p7 /mnt/swap # swap子卷(内存够且不需要休眠功能可考虑不用)
mount --mkdir /dev/nvme0n1p6 /mnt/efi # efi分区(ESP)
df -h # 检查挂载情况

# 关于 ESP 的挂载选在 /efi 而不是 /boot 的原因:
# /boot是传统做法, 但里面的内核文件做快照需要btrfs, 而ESP需要fat32, 冲突
# systemd-boot 暂不支持 /efi, 所以改用GRUB
# GRUB默认装在/boot/grub, 但grub在boot时无法写入btrfs分区中的配置文件grubenv, 会让记忆启动项功能失效
# 解决方式: grub放在ESP. 这个方案的额外好处是ESP只放.efi 和 grub, 所以分配给ESP的空间可以很小
# 注意: grub放ESP无法做快照, 更新grub后记得手动更新cfg文件; 如果不在意记忆启动项, grub可装默认位置

# 安装系统
pacstrap -K /mnt base base-devel linux linux-firmware btrfs-progs
# -K 初始化keyring
# base: 核心软件工具(可用 pactree -d1 base 看看)
# base-devel: 编译工具链
# linux: 内核本体, 可根据需求更换(如linux-zen)
# linux-firmware: 硬件设备的固件集合
# btrfs-progs: Btrfs 文件系统的管理工具
# 如果使用marvell的无线网卡, 要额外装linux-firmware-marvell, 否则进系统找不到网卡

# 安装基础工具
pacstrap /mnt networkmanager vim amd-ucode
# networkmanager: 用于联网
# amd-ucode 是微码, 用来修复和优化cpu, intel用户改为 intel-ucode

# swap(交换空间) 是虚拟的内存, 可以暂存一部分内存到硬盘, 也和休眠功能有关(系统写入硬盘, 断电快速开机)
# 内存够且不需要休眠功能可考虑不设置硬盘swap, 而只用内存做压缩的swap
# 此处用交换文件形式, 而不是交换分区形式, 更灵活
# 创建 swapfile, 空间比内存大一些(20g>本机16g内存)
btrfs filesystem mkswapfile --size 20g --uuid clear /mnt/swap/swapfile
# 启动swap
swapon /mnt/swap/swapfile

# 生成fstab文件(系统启动会根据文件内容进行挂载)
genfstab -U /mnt >> /mnt/etc/fstab # 将当前挂载情况写入fstab
# -U 用uuid指定分区 ; > 是覆盖写入, >> 是追加写入
cat /mnt/etc/fstab # 检查

# 进入新系统(live环境切换到/mnt新环境)
arch-chroot /mnt

echo "arch" > /etc/hostname # 给主机起个名字
vim /etc/hosts # 写入hosts内容(第三行的名称要和主机名一致)
# 127.0.0.1   localhost
# ::1         localhost
# 127.0.1.1   arch.localdomain arch

ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 设置时间时区
hwclock --systohc # 系统时钟写入主板硬件时钟

sed -i '/^#en_US.UTF-8/s/^#//' /etc/locale.gen # 取消 en_US.UTF-8 的注释
sed -i '/^#zh_CN.UTF-8/s/^#//' /etc/locale.gen # 取消 zh_CN.UTF-8 的注释
locale-gen # 生成本地化配置
echo "LANG=en_US.UTF-8" > /etc/locale.conf # 设置系统语言英文(别设中文, tty会乱码)

passwd root # 设置root密码

# 创建普通用户 (有些软件拒绝在root权限执行)
useradd -m -g wheel 用户名 # -m创建home目录, -g设置组
passwd 用户名 # 设置密码
EDITOR=vim visudo # 编辑权限: 取消注释 %wheel ALL=（ALL：ALL） ALL

# 设置安装引导程序(双系统)
# grub: 引导加载器(bootloader), 接管BIOS/UEFI, 显示多系统菜单, 引导加载Linux
# efibootmgr: 管理/修改 UEFI 启动项
# os-prober: 检测硬盘中的其他操作系统
# exfat-utils: 支持exFAT分区(免去手动挂载win的efi分区)
pacman -S grub efibootmgr os-prober exfat-utils
# 将 grub 引导文件安装到 EFI 分区
# 如果是移动设备, 或者主板只支持默认efi路径, 要加上--removable选项
grub-install --target=x86_64-efi --efi-directory=/efi --boot-directory=/efi --bootloader-id=ARCH
# 修改grub的源文件
vim /etc/default/grub
# 启动项记忆: GRUB_DEFAULT=0 改 =saved, 取消 GRUB_SAVEDEFAULT=true 的注释
# 开机日志: GRUB_CMDLINE_LINUX_DEFAULT, 去掉 quiet, loglevel 改为 5 (方便排错)
# 禁用watchdog: GRUB_CMDLINE_LINUX_DEFAULT 添加 nowatchdog, 和 modprobe.blacklist=(AMD填sp5100_tco;Intel填iTCO_wdt)
# 允许os-prober搜索其他系统: 取消 GRUB_DISABLE_OS_PROBER=false 的注释
# 备注: watchdog作用是死机时自动重启, 个人用户没用, 禁用可提高开关机速度

ln -sf /efi/grub /boot/grub # 在grub的默认安装位置创建软链接
grub-mkconfig -o /boot/grub/grub.cfg # 生成grub菜单

exit # 退出子系统, 回到live系统
# umount -R /mnt # 取消挂载

# 重启, 拔掉启动 U 盘, 等待 grub 菜单出现 Linux 和 Windows, 选择进入
# 若 Windows 配置了 Bitlocker, 初次从grub进入需要输入解密密钥
reboot

# 启用网络
systemctl enable --now NetworkManager
nmtui # TUI 界面选择连接 Wi-Fi, 或用下面两条命令
# nmcli dev wifi list # 显示附近的 Wi-Fi 网络
# nmcli dev wifi connect "Wi-Fi名(SSID)" password xxx
ip a

# 硬盘格式支持(选装): FAT, NTFS, exFAT, F2FS, 光盘格式, XFS
pacman -S dosfstools ntfs-3g exfat-utils f2fs-tools udftools xfsprogs

# 基础安装完成, 放松一下
pacman -S fastfetch lolcat cmatrix
fastfetch | lolcat
cmatrix | lolcat
```

# 脚本安装

可使用官方的`archinstall`脚本安装, 略

# 添加仓库

```bash
# 添加源
vim /etc/pacman.conf
# 开启32位源(steam, wine 需要): 去掉[multilib]两行的注释
# 下载线程数: ParallelDownloads 默认 5, 视情况修改
#
# CN源提供很多已经打包好的常用软件(省去AUR编译)
# 注: CN源依赖有时来不及和官方同步, 可能出问题. 建议: 遇到大系统更新时延迟更新, 注意官方公告; 或平时关闭CN源, 需要才开
# 添加 archlinuxcn 源 (文件底部写入)
# [archlinuxcn]
# Server = https://mirrors.cloud.tencent.com/archlinuxcn/$arch
# Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch
# Server = https://mirrors.aliyun.com/archlinuxcn/$arch

# 首次使用CN源, 安装密钥
pacman -Sy archlinuxcn-keyring
# 从CN源下载yay(AUR)
pacman -S yay

# 安装Flatpak(全依赖打包)
# Flatpak建议用于依赖和插件多的软件如obs和easyeffects
# 当仓库和AUR的软功能不正常时,件 可尝试换成Flatpak版本软件
pacman -S flatpak
# 设置Flathub源
flatpak remote-add --user --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
# 可选: 更换国内源
flatpak remote-modify flathub --url=https://mirrors.ustc.edu.cn/flathub # 中科大
# 注: 即便用镜像站 也需要网络能访问flathub官方仓库, 才能下载所有包
```

# 命令行工具安装

```bash
pacman -S bash-completion oh-my-posh trash-cli perl-image-exiftool
pacman -S openssh wget man-pages man-db less ouch zip unzip 7zip pacman-contrib
pacman -S stow tmux lsd bat bat-extras zoxide dust yazi tldr btop git-delta
pacman -S neovim fzf fd ripgrep lazygit jq imagemagick resvg poppler mdbook mediainfo
```

# 防火墙

```bash
pacman -S firewalld
systemctl enable --now firewalld
# 家用电脑, 关掉ssh端口, 需要时临时开启 firewall-cmd --add-service=ssh
firewall-cmd --zone=public --remove-service=ssh --permanent
firewall-cmd --reload # 重启服务
firewall-cmd --zone=public --list-all # 检查配置
```

# 配置数据快照

安装配置

```bash
# 1. 安装
# snapper: 创建/删除快照
# snap-pac: 快照钩子(执行pacman命令时自动创建快照)
# btrfs-assistant: 提供一些快捷命令以及GUI
# grub-btrfs: GRUB 菜单里显示 Btrfs 快照, 可从快照启动
# inotify-tools: 文件变动监听工具, 供 grub-btrfsd 监控快照变化并更新 GRUB 菜单
pacman -S snapper snap-pac btrfs-assistant grub-btrfs inotify-tools
# 注: 安装后需要重启, 用新的initramfs进入系统, snap-pac才生效
# 2. 生成快照启动项服务
systemctl enable --now grub-btrfsd
# 3. 构建一次grub配置文件, 用于生成grub菜单的snapshot入口
grub-mkconfig -o /boot/grub/grub.cfg
```

手动新建一份快照

```bash
# 配置一份初始快照(root + home)
snapper -c root create-config /     # 生成root子卷配置
snapper -c home create-config /home # 生成home子卷配置
snapper list-configs # 查看配置
# 修改自动生成的策略: TIMELINE_CREATE 和 TIMELINE_CLEANUP 设置为 no
vim /etc/snapper/configs/root
vim /etc/snapper/configs/home
# 新建快照
snapper -c root create --description "init(root)"
snapper -c home create --description "init(home)"
```

快照回档

```bash
# 方法1: 使用 snapper 命令行
# 注: 官方不建议undochange命令滚root, 而rollback命令不支持arch的子卷布局. 因此不建议用
# 示例: 回滚 root 子卷的快照
snapper -c root list # 查看快照, 记住快照号
snapper -c root undochange n..0 # 回滚到n号快照状态

# 方法2: 使用 btrfs-assistant 命令行
su - # 需要切换到root用户
btrfs-assistant -l # 查看快照id
btrfs-assistant -r 快照id # 执行回滚
reboot # 重启, 完成快照回滚

# 方法3: 使用 btrfs-assistant 图形界面
# 1. 创建配置
#       打开 btrfs-assistant, 切换到snapper settings页面.
#       之前设置了两个子卷: @ 和 @home, 所以需要建两个config
#       新建一个config:
#           点击new config新建配置, config name写root, backup path选择 / , 然后点击save保存.
#           可以设置一些自动生成快照的策略, systemd unit settings里面有三个服务:
#                timeline是按照时间计划自动创建快照;
#                cleanup是快照数量达到number设定的数量上限之后自动清理快照;
#                boot是每次开机自动创建快照;
#           按需设置, 设置完点apply
#       重复上面操作, 生成 home 的 config
# 2. 创建快照
#       到snapper页面, select config选择配置, 选择想创建快照的子卷的config, 点击new创建快照, description写描述
# 3. 使用快照进行恢复
#       snapper页面 --> Browse/restore页面
#       select target 选择想恢复的子卷, 再选择想使用的快照, 点击restore (此时会自动给你创建一个当前子卷数据的备份)
# 4. 使用快照进行全盘恢复
#       虽然root目录(/)包含home目录(/home), 但前面 root 子卷和 home 子卷创建的时候是平级的(子卷布局是"扁平布局"),
#       所以创建 root 子卷的快照不包含home子卷的内容. 所以需要分别创建 root 和 home 的快照, 并分别做恢复

# 方法4: 从 GRUB 菜单的快照启动项进入系统并回档
#
# 重启后进入 GRUB 界面, 选快照, 选 "vmlinuz-linux & initramfs-linux.img"
# 系统会启动到一个只读的快照环境, 可能不会进图形界面, 在日志停止输出时, 按 Ctrl + Alt + F2 切换到 TTY, root账号登录
#
# 此时的 / 目录是一个快照子卷的根目录, 而不是原系统的 @ 子卷
# snapper 是基于“当前 root 子卷 + 对应配置”工作的
# 因此在该环境中 snapper 只能看到当前快照视角(0), 而不会列出原系统 root 子卷的快照信息
# 我们需要额外挂载的方式查看snapper的快照的备注, 然后通过btrfs-assistant命令去执行回滚
#
# 执行下列命令:
export LC_ALL="en_US.UTF-8" # 确保命令输出英文
mkdir /run/root # 在/run(快照系统中可读写)中建文件夹用于挂载(或不创建, 找个空文件夹)
mount -t btrfs /dev/nvme0n1p7 /run/root # 挂载系统根的硬盘分区
# 注: mount的时候可加 -o subvol=/@, 加了后snapper list的时候用 --root /run/root
snapper --no-dbus --root /run/root/@ -c root list # 读取快照信息, 找需要恢复的root子卷快照编号
btrfs-assistant -l # 查看完整快照列表, 根据root子卷及其快照编号, 获取快照总编号
btrfs-assistant -r [快照总编号] # 恢复快照
reboot # 重启系统
#
# 参数解释:
# --no-dbus:
#   快照启动环境中 systemd / D-Bus 不完整, snapper 无法通过 D-Bus 工作, 需要禁用 D-Bus, 否则命令报错
# --root /run/root:
#   snapper 的 --root 参数必须指向 "已挂载的 btrfs 根目录"
#   不能直接写块设备(/dev/nvme0n1p7), snapper 不会也不能自己去 mount 设备
#   /run/root 是临时挂载点, 指向原系统的 btrfs 顶层, 可正确读取 snapper 配置和快照元数据
#
# 命令输出示例:
#   $ snapper --no-dbus --root /run/root -c root list
#   # │ Type   │ Pre # │ Date                            │ User │ Cleanup │ Description     │ Userdata
#   ──┼────────┼───────┼─────────────────────────────────┼──────┼─────────┼─────────────────┼─────────
#   0 │ single │       │                                 │ root │         │ current         │
#   1 │ single │       │ Mon 01 Jan 2046 00:00:01 AM CST │ root │ number  │ quick-root-1    │
#   2 │ single │       │ Mon 01 Jan 2046 00:00:02 AM CST │ root │ number  │ quick-root-2    │
#   $ sudo btrfs-assistant -l
#   1    @        1    Mon Jan 01 00:00:01 2046    single    @/.snapshots/1/snapshot
#   2    @        2    Mon Jan 01 00:00:01 2046    single    @/.snapshots/2/snapshot
#   3    @home    1    Mon Jan 01 00:00:02 2046    single    @home/.snapshots/1/snapshot
#   4    @home    2    Mon Jan 01 00:00:02 2046    single    @home/.snapshots/2/snapshot
#
# 注: 
# 在 BusyBox-based 的 initramfs 中, 可设置 grub-btrfs-overlayfs,
# 通过设置 overlayfs, 在内存中构建临时可写根, 使系统可正常进入图形界面, 方便GUI回滚操作
# 改 /etc/mkinitcpio.conf , 在 HOOKS 末尾加入 grub-btrfs-overlayfs
# 然后mkinitcpio -P (重新生成initramfs), 重启
# 不过 systemd-based initramfs 不支持, 因此本系统未采用该方案
# 具体可参考 Snapper 的 ArchWiki
```

关于更新:

1. 一般软件问题不大, 但更新出现 keyring, 内核, 驱动, 固件, 引导程序之类的, 要小心.
2. 滚动更新发行版的软件通常适配最新依赖, 部分更新可能无法使用软件

使用原则:

1. 别第一时间更新, 别长时间不更新, 别部分更新, 先单独更新 keyring, 重要程序更新前创建快照
2. 系统挂通常更多是用户不当操作, 做不了解的事情前记得创建快照

---

有时候应用更新完后不好用, 或依赖不兼容, 可以不用快照回滚, 而用 downgrade 对个别的包进行版本回退

```bash
yay -S downgrade
sudo downgrade 要回退的软件包
```

# 删除系统

若需要删除双系统的 Linux, 按以下步骤操作

```bash
# PowerShell执行(管理员权限)
diskpart
list disk # 查看硬盘
select disk 0 # 选择硬盘编号
list partition # 查看分区
# 重复执行下面两步, x填入清除的分区编号, 然后执行delete操作
select partition x
delete partition override

# 如果Linux和Windows共享了同一个EFI分区, 执行下面操作
diskpart
list disk # 查看硬盘
select disk 0 # 选择硬盘编号
select partition 1 # 选择EFI所在的分区
assign letter p # 分配一个盘符p
# 管理员身份打开"记事本" -> 点"保存", 保存类型选"所有文件" -> 进入盘符p目录, 删除里面Linux相关文件
# 删除后, 留下的文件夹是 "Boot", "Microsoft" 这样的字眼
remove letter p # 操作完成, 移除盘符

# UEFI中的系统启动项需要清理的话可以用BOOTICE之类的软件
```
